-- Examples from the paper

-- Section 2.1

data Zero =

data Bool = tt | ff

data Nat = zero | suc Nat

data List X = nil | cons X (List X)

data Pair X Y = pair X Y

append : List X -> List X -> List X
append nil ys = ys
append (cons x xs) ys = cons x (append xs ys)

-- Section 2.2

map : {X -> []Y} -> List X -> []List Y
map f nil = nil
map f (cons x xs) = cons (f x) (map f xs)

-- Section 2.3

fst : X -> Y -> X
fst x y = x

snd : X -> Y -> Y
snd x y = y

if : Bool -> {X} -> {X} -> X
if tt t f = t!
if ff t f = f!

on : X -> {X -> Y} -> Y
on x f = f x

shortAnd : Bool -> {Bool} -> Bool
shortAnd x c = on x {tt -> c! | ff -> ff}

-- Section 2.4

interface Send X = send : X -> Unit

interface Receive X = receive : X

interface State S = get : S
 | put : S -> Unit

interface Abort = aborting : Zero

abort : [Abort]X
abort! = on aborting! {}

main : Unit
main! = unit
