-- Computation as Data

interface LookAhead = peek : Char | accept : Unit

data Log [] X = start {[]X}
              | inched (Log [] X) {Char -> []X}
	      | ouched (Log [] X)

data Buffer = empty | hold Char

input :  Log [LookAhead, Abort, CursesConsole] X ->
         Buffer ->
         <LookAhead, Abort>X ->
         [CursesConsole]X
input _ _        x               = x
input l (hold c) <peek -> k>     =
  input l (hold c) (k c)
input l (hold c) <accept -> k>   =
  ouch c; input (ouched l) empty (k unit)
input l empty    <accept -> k>   =
  input l empty (k unit)
input l empty    <peek -> k>     = on inch!
  {'\b' -> rollback l
  | c   -> input (inched l k) (hold c) (k c) }
input l _        <aborting -> k> = rollback l

rollback : Log [LookAhead, Abort, CursesConsole] X ->
           [CursesConsole]X
rollback (start p)    = parse p
rollback (ouched l)   = map ouch "\b \b"; rollback l
rollback (inched l k) = input l empty (k peek!)

parse : {[LookAhead, Abort, CursesConsole]X} -> [CursesConsole]X
parse p = input (start p) empty p!

-- Not in paper but applies above code to an example
data Zero =

interface Abort = aborting : Zero

data Nat = zero | suc Nat

on : X -> {X -> Y} -> Y
on x f = f x

abort : [Abort]X
abort! = on aborting! {}

map : {a -> b} -> List a -> List b
map f nil = nil
map f (cons x xs) = cons (f x) (map f xs)

main : [CursesConsole]String
main! = parse {blah zero}

blah : Nat -> [LookAhead, Abort, CursesConsole]String
blah  zero   = on peek! { '(' -> accept!; blah (suc zero)
                        | c -> abort! }
blah (suc n) = on peek! { '(' -> accept!; blah (suc (suc n))
                        | ')' -> accept!; blah n
                        | c -> accept!; blah (suc n) }
